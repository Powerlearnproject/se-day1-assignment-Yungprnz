[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=15566108&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry.


Software engineering deals with the design, development, testing, deployment and maintenance of software programs. Software engineering applies engineering principles, tools and knowledge to develop software applications for use by end users. Software engineering plays a crucial role in the technology industry as it enables the creation of powerful softwares that are essential in various aspects of life including education, commerce, sports, finance, healthcare, information and entertainment. 

Identify and describe at least three key milestones in the evolution of software engineering.

Key milestones in the evolution of software engineering include:
-  Mastering the Machine (1956–1967): The term software engineering had not yet been coined. Code development was strongly influenced by outside forces. The main purpose of any piece of software was to optimize exploitation of the limited hardware resources. The first compilers were defined; operating systems were noninteractive.
-  Mastering the Process (1968-1982): The first software crisis led to the birth of software engineering as a field in the 1960s to optimize creating software without compromising on its quality. The aim was to reduce risk during development and improve quality and productivity. Software development methodologies appeared to define and monitor software building.
-  Mastering the Complexity (1983–1992): The up to then dominion of hardware over software ended. Personal computers arrived and opened the fields of computer applications. The software development process would now comprehensively address analysis and design from the specification. Graphical user interface and visual programming brought software closer to customers.

List and briefly explain the phases of the Software Development Life Cycle.

- Planning: In this phase, the project leads to defining the project's purpose and defining the desired result. If the team is developing for a customer instead of to market, the project manager meets with them to discuss the product, its purpose, and the results they want to achieve. The team gathers as much information about the product from the customer.
- Requirement: This is often done concurrently with planning. Here, the project lead analyzes the product or client’s goals and decides on the features to aim for as a final goal. Defining and establishing requirements determines what the application will do once launched, the necessary components, and the resources needed to launch it.
- Desigin: The design phase defines how a software application will work. During this phase, teams decide on the programming language, screen layouts, and relevant documentation they will use. Some of the fundamental aspects developers cover during this phase are architecture, user interface, security, programming. Prototyping is also part of this phase. A prototype is a basic idea of how the application looks and works. Prototypes allow customers to get a sneak peek of how their application will look
- Implementation: Developers start programming in this phase. If they work on a small project, one developer takes over the coding tasks, while on large projects, the codebase might be worked on by several developers. Before starting to code, teams must have clear predefined guidelines to ensure the code’s quality. In this phase, developers start building the entire system and shaping the project.
- Testing: Often, testing happens in parallel with development, as developers write and test the code they’ve produced before moving on to the next coding task. During this phase, different types of testing occur, such as code quality, unit testing, integration testing, performance testing, and security testing. Running testing in parallel with development means that bugs can be fixed within the same sprint or time block, which is more efficient than adding a whole block of coding to be done at the end of the project.
- Deployment: The deployment process starts once the testing phase is over and there are no bugs or errors in the development backlog. The team ensures that the software is up-to-date and secure enough for users and pushes it from the development environment to a live environment–usually an app store. During this phase, the tech support team looks for user feedback and ensures it reaches the dev team.
- Maintenance: At this point in the SDLC cycle, the application is successfully launched and being used. This last phase is still important because bugs or errors missed during testing are bound to appear. By studying user behavior and feedback, the team can start to think about and plan for upgrades.

Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.

Waterfall is a linear system of working that requires the team to complete each project phase before moving on to the next one while Agile encourages the team to work simultaneously on different phases of the project. Agile methodology was developed as a response to Waterfall’s more rigid structure. As a result, it’s a much more fluid form of project management. Waterfall methodology requires completing deliverables to progress to the next phase of a project. 
Waterfall methodology is better suited for a projects with regulations or requirements because each phase’s deliverables and strict procedures ensure that they are met. For instance, the Department of Defense and the aerospace industry are a couple of industries that would more likely use Waterfall over Agile, since the requirements are a safety factor.
Agile methodology is better suited for projects where the outcome may be dependent on more research or testing. 

Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.

- Software Developer: is task with the responsibility of writing the codes and developing the entire software product. Aside from coding, a software developer is responsible for sending updates to the project manager and working closely with other team members, including the designer and QA engineer. 
- Quality Assurance Engineer: is responsible for ensuring the designed software meets the desired quality standard. QA engineers examine programs to identify bugs and defects, especially when they appear unexpectedly. To evaluate the effectiveness of various product functionalities and aspects, they frequently use a variety of tests.
- Project Manager: is responsible for overseeing the planning, execution and delivery of software projects. They align project objectives with business goals, manage resources and mitigate risks. They are responsible for ensuring the success of the project.

Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.

- Integrated Development Environments (IDEs): are essential software tools that provide a comprehensive set of tools for developing software applications efficiently. IDEs offers all features that may be necessary for software development. They provide an all-in-one environment for a developer: Coding, compiling, debugging, and managing the projects. IDEs typically include a code editor, debugger, build automation tools, and integrated version control all in one place. Examples include Visual Studio Code, IntelliJ IDEA, Eclipse, Xcode, and Android Studio.
- Version Control Systems (VCS): They keeps track of every modification to the code in a special kind of database. If a mistake is made, developers can turn back the clock and compare earlier versions of the code to help fix the mistake while minimizing disruption to all team members. They allow developers to track changes, commit updates, and merge code efficiently. Examples include Git, Subversion.

What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.

- Changing Requirements: Software projects often experience changes in requirements, which can disrupt the development process and lead to delays.
- Meeting deadlines: Developers often work under tight deadlines, which can make it difficult to ensure the quality of the final product.
- Debugging: Debugging software can be time-consuming and complex, particularly for large and complex systems.
- Limited Infrastructure: The lack of proper IT infrastructure can significantly impact the productivity of software development teams.
- Security: Providing complete Security to the software applications is a major challenge for developers as hackers are trying each moment to hack the software applications and steal the data.
- Keeping up with new technologies: Software development is a rapidly evolving field, and developers must constantly learn new technologies and programming languages to stay current.
- Collaboration: Collaborating with other team members, such as project managers, designers, and other developers, can be challenging as everyone have different working styles and goals.

Strategies for overcoming these challenges include:
-  Use project management techniques such as Agile development and Scrum to plan, manage work effectively and handle changing requirements.
-  Use software testing and quality assurance techniques to ensure the quality of software systems, and conduct code reviews to identify and fix issues early on.
-  Use debugging tools and techniques to simplify the debugging process and make it more efficient.
-  Continuously learn and explore new technologies and programming languages to stay current.
-  Use collaboration tools such as communication platforms and version control systems to facilitate effective collaboration among team members.

Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.

-  Unit testing: Unit tests focus on individual components, such as methods and functions. It is a testing technique wherein the simple or smallest units of a software program are examined personally for bugs and errors.
-  Integration testing: Integration tests check if these components work together properly.
-  System testing: refers to the testing of a software module to check if the functional requirements are met or not and whether the module is functioning properly or not.
-  Acceptance testing: refers to testing the software on the client side and checking if it functions properly or not in the client environment and the client accepts the software.

#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.

Prompt engineering is a art for crafting effective prompts to help get the best results from AI model. It ensures that AI model produce relevant and accurate results. By strategically designing prompts, users can guide models to produce accurate, relevant, and context-aware responses for various tasks.
Prompt engineering is important in interacting with AI models as it helps ensure that the generated output meets your expectations and requirements. This can improve clarity, consistency, and relevance in the responses, making them more useful and easier to understand making it more user-friendly basically.

Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.

- Vague prompt: Write a code for adding numbers.

- Improved prompt: Write a python code that requests two inputs from a user, then find the sum of the two inputted numbers and display the result on the console.

The vague prompt is not clear and is ambiguous as no programming language is specified. The improved prompt is more effective in the sense that it specifies the programming language the results from the AI model is expected and it gives a clear and concise request to the AI model.

